/*
 *  Copyright 2006-2011 WebPKI.org (http://webpki.org).
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */
package org.webpki.tools;

import java.util.Collection;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.TreeSet;
import java.util.Vector;

import java.io.FileOutputStream;
import java.io.File;
import java.io.IOException;

import org.webpki.util.ArrayUtil;

import org.webpki.xml.DOMAttributeReaderHelper;
import org.webpki.xml.DOMReaderHelper;
import org.webpki.xml.DOMWriterHelper;
import org.webpki.xml.XMLObjectWrapper;
import org.webpki.xml.XMLSchemaCache;

/**
 * From an XML description file create Web Services artifacts.
 * 
 * @author Anders Rundgren
 */
public class WSCreator extends XMLObjectWrapper
  {
    private static final String JCLIENT = "jclient";
    private static final String JSERVER = "jserver";
    private static final String WSDL = "wsdl";
    private static final String DOTNETCLIENT = "dotnetclient";

    private static final String VERSION = "1.0";

    private static String GENERATED = "Generated by " + WSCreator.class.getSimpleName () + " " + VERSION + " - Do not edit!";

    private static boolean jclient;
    private static boolean jserver;
    private static boolean wsdl_gen;
    private static boolean dotnet_gen;

    private static String output_directory;

    private FileOutputStream wsdl_file;

    private String license_header = "";

    void genSlashes (FileOutputStream file) throws IOException
      {
        write (file, "        ");
        for (int i = -6; i < GENERATED.length (); i++)
          {
            write (file, "/");
          }
        write (file, "\n");
      }

    void writeGenerate (FileOutputStream file) throws IOException
      {
        genSlashes (file);
        writeln (file, "        // " + GENERATED + " //");
        genSlashes (file);
      }

    abstract class Package
      {
        FileOutputStream jfile;
        String class_name;
        String class_header = "";
        String package_name;
        String path;
        boolean next;
        boolean schema_validation;
        String jserver_support_code = "";
        String dot_net_support_code = "";

        abstract String decoration ();

        abstract String class_interface ();
        
        abstract boolean is_server ();

        Package (DOMReaderHelper rd, String elem, WSCreator owner, boolean dot_net) throws IOException
          {
            rd.getNext (elem);
            schema_validation = attr.getBooleanConditional ("SchemaValidation");
            String canonicalized_class_name = attr.getString ("ClassName");
            boolean path_as_directory = attr.getBooleanConditional ("PathAsDirectory", true);
            dot_net_registry_url = attr.getStringConditional ("RegistryURL");
            if (dot_net_registry_url != null)
              {
                StringBuffer reg = new StringBuffer ();
                for (char c : dot_net_registry_url.toCharArray ())
                  {
                    reg.append (c);
                    if (c == '\\')
                      {
                        reg.append (c);
                      }
                  }
                dot_net_registry_url = reg.toString ();
              }
            dot_net_default_url = attr.getStringConditional ("DefaultURL");

            String[] imports = attr.getListConditional ("Imports");
            if (jserver && is_server ())
              {
                if (imports != null)
                  {
                    for (String string : imports)
                      {
                        owner.addImport (string);
                      }
                  }
                if (add_main = attr.getBooleanConditional ("AddMain"))
                  {
                    owner.addImport ("javax.xml.ws.Endpoint");
                  }
              }
            else if (imports != null && dot_net)
              {
                for (String string : imports)
                  {
                    dotnet_imports.add (string);
                  }
              }
            class_name = canonicalized_class_name;
            path = output_directory;
            int i = canonicalized_class_name.lastIndexOf ('.');
            if (i > 0)
              {
                class_name = canonicalized_class_name.substring (i + 1);
                package_name = canonicalized_class_name.substring (0, i);
                if (path_as_directory)
                  {
                    path += File.separatorChar;
                    for (int j = 0; j < i; j++)
                      {
                        path += canonicalized_class_name.charAt (j) == '.' ? File.separatorChar : canonicalized_class_name.charAt (j);
                      }
                  }
              }
            rd.getChild ();
            if (rd.hasNext ("ClassHeader"))
              {
                class_header = rd.getString ("ClassHeader");
              }
            if ((is_server() || dot_net) && rd.hasNext ("SupportCode")) 
              {
                if (is_server ())
                  {
                    jserver_support_code = rd.getString ("SupportCode");
                  }
                else
                  {
                    dot_net_support_code = rd.getString ("SupportCode");
                  }
              }
            if (dot_net) while (rd.hasNext ("RewriteRule"))
              {
                rd.getNext ("RewriteRule");
                String rule = attr.getString ("DotNetRule");
                if (dot_net_rules.put (rule, new DotNetRule (attr.getString ("ActualType"),
                                                             attr.getString ("Conversion"))) != null)
                  {
                    bad ("Duplicate rewrite rule: " + rule);
                  }
              }
            rd.getParent ();
          }

        public void writePackage () throws IOException
          {
            write (jfile, license_header);
            if (package_name != null)
              {
                writeln (jfile, "package " + package_name + ";");
              }
            write (jfile, "\n");
            writeGenerate (jfile);
          }

        public void writeImports () throws IOException
          {
            String last_import_pack = "";
            for (String impstr : dotnet_gen ? dotnet_imports : jimports)
              {
                int i = impstr.lastIndexOf ('.');
                if (i < 0) i = impstr.length ();
                if (!last_import_pack.equals (impstr.substring (0, i)))
                  {
                    write (jfile, "\n");
                    last_import_pack = impstr.substring (0, i);
                  }
                writeln (jfile, (dotnet_gen ? "    using " : "import ") + impstr + ";");
              }
          }
      }

    class ServerPack extends Package
      {
        ServerPack (DOMReaderHelper rd, WSCreator parent) throws IOException
          {
            super (rd, "JavaServer", parent, false);
          }

        @Override
        String decoration ()
          {
            return ",\n" +
                   "            name=\"" + service_name + ".Interface\",\n" +
                   "            portName=\"" + service_name + ".Port\",\n" +
                   "            wsdlLocation=\"" + wsdl_location + "\"";
          }

        @Override
        String class_interface ()
          {
            return "class";
          }

        @Override
        boolean is_server ()
          {
            return true;
          }

      }

    class ClientPack extends Package
      {
        ClientPack (DOMReaderHelper rd, boolean dot_net, WSCreator parent) throws IOException
          {
            super (rd, dot_net ? "DotNetClient" : "JavaClient", parent, dot_net);
          }

        @Override
        String decoration ()
          {
            return "";
          }

        @Override
        String class_interface ()
          {
            return "interface";
          }

        public void openAddedClass (String class_name) throws IOException
          {
            jimports.clear ();
            jfile = new FileOutputStream (path + File.separatorChar + class_name + ".java");
            writePackage ();
          }

        @Override
        boolean is_server ()
          {
            return false;
          }

      }

    ServerPack jserver_pck;

    ClientPack jclient_pck;

    ClientPack dotnet_client_pck;

    TreeSet<String> jimports = new TreeSet<String> ();

    TreeSet<String> dotnet_imports = new TreeSet<String> ();

    DOMAttributeReaderHelper attr;

    private String tns;

    private boolean qualified_ns;

    String wsdl_location;

    String sub_target_ns;

    private String service_name;

    private String default_url;

    static class DataType
      {
        boolean nullable;
        String xsd_name;
        String enum_name;
        String csname;
        String jname;
        String jholder;

        DataType (boolean nullable, String xsd_name, String enum_name, String csname, String jname, String jholder)
          {
            this.nullable = nullable;
            this.xsd_name = xsd_name;
            this.enum_name = enum_name;
            this.csname = csname;
            this.jname = jname;
            this.jholder = jholder;
          }
      }

    static Vector<DataType> types = new Vector<DataType> ();

    static
      {
        types.add (new DataType (false, "xs:int", "int", "int", "int", "Integer"));
        types.add (new DataType (false, "xs:short", "short", "short", "short", "Short"));
        types.add (new DataType (false, "xs:byte", "byte", "sbyte", "byte", "Byte"));
        types.add (new DataType (false, "xs:boolean", "boolean", "boolean", "boolean", "Boolean"));
        types.add (new DataType (true, "xs:string", "string", "string", "String", "String"));
        types.add (new DataType (true, "xs:base64Binary", "binary", "byte[]", "byte[]", "byte[]"));
      }

    class Property extends Container
      {
        DataType data_type;

        boolean nullable;

        boolean listtype;
        
        DotNetRule dot_net_rule;

        String jName (boolean object_type)
          {
            return object_type || listtype ? (listtype ? "List<" + data_type.jholder + ">" : data_type.jholder) : data_type.jname;
          }

        String nName ()
          {
            return listtype ? "List<" + data_type.csname + ">" : data_type.csname;
          }
        
        String nRealTypeName ()
          {
            return (dot_net_rule == null ? nName () : dot_net_rule.simple_type) +
                    ((listtype && dot_net_rule != null) ? "[] " : " ") + name;
          }

        public String nArgument (String prefix)
          {
            String arg = prefix  + name;
            if (dot_net_rule != null)
              {
                String sub = arg;
                arg = dot_net_rule.conversion;
                int i = 0;
                while (i < arg.length ())
                  {
                    if (arg.charAt (i++) == '$')
                      {
                        arg = arg.substring (0, i - 1) + sub + arg.substring (i);
                      }
                  }
              }
            return arg;
          }
      }

    abstract class Container
      {
        String name;
        String xml_name;

        public String getXMLName ()
          {
            return xml_name == null ? name : xml_name;
          }

      }

    class Method extends Container
      {
        String[] execptions;

        String code;

        public String getXMLResponseName ()
          {
            return getXMLName () + ".Response";
          }

        Collection<Property> inputs;
        Collection<Property> outputs;

        private void nTypedList (boolean next, boolean out, boolean real_type, Collection<Property> props) throws IOException
          {
            for (Property prop : props)
              {
                if (next)
                  {
                    write (dotnet_client_pck.jfile, ", ");
                  }
                else
                  {
                    next = true;
                  }
                write (dotnet_client_pck.jfile, (out ? "out " : "") + (real_type ? prop.nRealTypeName () : prop.nName () + " " + prop.name));
              }
          }

        public void writeNetTypedInput (boolean real_type) throws IOException
          {
            nTypedList (false, false, real_type, inputs);
          }

        public void writeNetTypedOutput () throws IOException
          {
            nTypedList (inputs.size () != 0, true, true, outputs);
          }

        public String getNetWrapper (boolean request)
          {
            return name + (request ? "_Request" : "_Response");
          }
      }

    class WSException extends Container
      {
        String class_name;

        String getName ()
          {
            return jclient ? name + "_Exception" : name;
          }

        String getBeanName ()
          {
            return name + "Bean";
          }

        Collection<Property> properties;
      }
    
    class DotNetRule
      {
        DotNetRule (String full_path, String conversion)
          {
            int i = full_path.lastIndexOf ('.');
            using_declaration = full_path.substring (0, i);
            simple_type = full_path.substring (i + 1);
            this.conversion = conversion;
            dotnet_imports.add (using_declaration);
          }
        
        String using_declaration;
        String simple_type;
        String conversion;
      }

    private LinkedHashMap<String, WSException> exceptions = new LinkedHashMap<String, WSException> ();
    private Vector<Method> methods = new Vector<Method> ();
    private LinkedHashMap<String, DotNetRule> dot_net_rules = new LinkedHashMap<String, DotNetRule> ();
    private boolean add_main;
    private String dot_net_registry_url;
    private String dot_net_default_url;

    @Override
    protected boolean hasQualifiedElements ()
      {
        return true;
      }

    @Override
    protected void init () throws IOException
      {
        addSchema ("wscreator.xsd");
      }

    @Override
    protected void fromXML (DOMReaderHelper rd) throws IOException
      {
        attr = rd.getAttributeHelper ();
        if (wsdl_gen)
          {
            wsdl_file = new FileOutputStream (output_directory);
          }
        tns = attr.getString ("NameSpace");
        default_url = attr.getString ("DefaultURL");
        service_name = attr.getString ("Service");
        qualified_ns = attr.getBoolean ("Qualified");
        wsdl_location = attr.getString ("WSDLLocation");
        sub_target_ns = qualified_ns ? "\", targetNamespace=\"" + tns + "\"" : "\"";

        rd.getChild ();

        addImport ("javax.jws.WebMethod");
        addImport ("javax.jws.WebService");

        addImport ("javax.xml.ws.RequestWrapper");
        addImport ("javax.xml.ws.ResponseWrapper");

        if (rd.hasNext ("LicenseHeader"))
          {
            license_header = rd.getString ("LicenseHeader");
          }

        write (wsdl_file, "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" + "<!--\n" + license_header + "\n");
        writeGenerate (wsdl_file);
        write (wsdl_file, "\n-->\n" + "<wsdl:definitions targetNamespace=\"" + tns + "\"\n" +
            "                  xmlns:wsdl=\"http://schemas.xmlsoap.org/wsdl/\"\n" + "                  xmlns:tns=\"" + tns + "\"\n" + "                  xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"\n" + "                  xmlns:soap=\"http://schemas.xmlsoap.org/wsdl/soap/\">\n\n" + "  <wsdl:types>\n\n" + "    <xs:schema targetNamespace=\"" + tns + "\"\n" + "               elementFormDefault=\"" + (qualified_ns ? "qualified" : "unqualified") + "\" attributeFormDefault=\"unqualified\">\n");

        if (rd.hasNext ("JavaServer"))
          {
            jserver_pck = new ServerPack (rd, this);
            if (jserver)
              {
                open (jserver_pck, true);
              }
          }
        else if (jserver)
          {
            bad ("The '" + JSERVER + "' option requires a \"JavaServer\" definition!");
          }
        if (rd.hasNext ("JavaClient"))
          {
            jclient_pck = new ClientPack (rd, false, this);
            if (jclient)
              {
                open (jclient_pck, true);
              }
          }
        else if (jclient)
          {
            bad ("The '" + JCLIENT + "' option requires a \"JavaClient\" definition!");
          }
        if (rd.hasNext ("DotNetClient"))
          {
            dotnet_client_pck = new ClientPack (rd, true, this);
            dotnet_imports.add ("System.Collections.Generic");
            if (dotnet_gen)
              {
                open (dotnet_client_pck, false);
              }
          }
        else if (dotnet_gen)
          {
            bad ("The '" + DOTNETCLIENT + "' option requires a \"DotNetClient\" definition!");
          }
        while (rd.hasNext ("Exception"))
          {
            rd.getNext ("Exception");
            WSException exception = new WSException ();
            exception.name = exception.class_name = attr.getString ("ClassName");
            if (jserver)
              {
                addImport (exception.name);
              }
            int i = exception.name.lastIndexOf ('.');
            if (i++ > 0)
              {
                exception.name = exception.name.substring (i);
              }
            exception.xml_name = attr.getStringConditional ("XMLName");
            rd.getChild ();
            exception.properties = getProperties (rd, "Property");
            rd.getParent ();
            exceptions.put (exception.name, exception);
          }
        do
          {
            rd.getNext ("Method");
            Method method = new Method ();
            method.name = attr.getString ("Name");
            method.xml_name = attr.getStringConditional ("XMLName");
            method.execptions = attr.getListConditional ("Throws");
            if (method.execptions == null) method.execptions = new String[0];
            rd.getChild ();
            method.inputs = getProperties (rd, "Input");
            method.outputs = getProperties (rd, "Output");
            if (method.outputs.size () == 1)
              {
                addImport ("javax.jws.WebResult");
              }
            else if (method.outputs.size () > 1)
              {
                addImport ("javax.jws.WebParam");
                addImport ("javax.xml.ws.Holder");
              }
            String code = rd.getStringConditional ("Code");
            method.code = jserver ? "\n      {" + (code == null ? "\n" : code) + "      }" : ";";
            rd.getParent ();
            for (String exception : method.execptions)
              {
                if (!exceptions.containsKey (exception))
                  {
                    bad ("Exception '" + exception + "' missing declaration");
                  }
              }
            methods.add (method);
          }
        while (rd.hasNext ("Method"));

        for (WSException exception : exceptions.values ())
          {
            writeWSDLProperties (exception.getXMLName (), exception.properties, qualified_ns);
          }

        for (Method meth : methods)
          {
            writeWSDLProperties (meth.getXMLName (), meth.inputs, false);
            writeWSDLProperties (meth.getXMLResponseName (), meth.outputs, false);
          }

        write (wsdl_file, "\n    </xs:schema>\n\n  </wsdl:types>\n");

        for (WSException exception : exceptions.values ())
          {
            write (wsdl_file, "\n" + "  <wsdl:message name=\"" + exception.getXMLName () + "\">\n" + "    <wsdl:part name=\"fault\" element=\"tns:" + exception.getXMLName () + "\"/>\n" + "  </wsdl:message>\n");
          }

        for (Method meth : methods)
          {
            write (wsdl_file, "\n" + "  <wsdl:message name=\"" + meth.getXMLName () + "\">\n" + "    <wsdl:part name=\"parameters\" element=\"tns:" + meth.getXMLName () + "\"/>\n" + "  </wsdl:message>\n\n" + "  <wsdl:message name=\"" + meth.getXMLResponseName () + "\">\n" + "    <wsdl:part name=\"parameters\" element=\"tns:" + meth.getXMLResponseName () + "\"/>\n" + "  </wsdl:message>\n");
          }

        write (wsdl_file, "\n  <wsdl:portType name=\"" + service_name + ".Interface\">\n");

        for (Method meth : methods)
          {
            write (wsdl_file, "\n" + 
                              "    <wsdl:operation name=\"" + meth.getXMLName () + "\">\n" +
                              "      <wsdl:input message=\"tns:" + meth.getXMLName () + "\"/>\n" +
                              "      <wsdl:output message=\"tns:" + meth.getXMLResponseName () + "\"/>\n");
            for (String exception : meth.execptions)
              {
                String xml_name = exceptions.get (exception).getXMLName ();
                write (wsdl_file, "      <wsdl:fault message=\"tns:" + xml_name + "\" name=\"" + xml_name + "\"/>\n");
              }
            write (wsdl_file, "    </wsdl:operation>\n");
          }

        write (wsdl_file, "\n  </wsdl:portType>\n\n" + "  <wsdl:binding name=\"" + service_name + ".Binding\" type=\"tns:" + service_name + ".Interface\">\n" + "    <soap:binding style=\"document\" transport=\"http://schemas.xmlsoap.org/soap/http\"/>\n");

        javaHeader (jserver_pck);
        javaHeader (jclient_pck);

        for (Method meth : methods)
          {
            javaMethod (jserver_pck, meth);
            javaMethod (jclient_pck, meth);
            write (wsdl_file, "\n" + "      <wsdl:operation name=\"" + meth.getXMLName () + "\">\n" + "        <wsdl:input>\n" + "          <soap:body use=\"literal\"/>\n" + "        </wsdl:input>\n" + "        <wsdl:output>\n" + "          <soap:body use=\"literal\"/>\n" + "        </wsdl:output>\n");
            for (String exception : meth.execptions)
              {
                String xml_name = exceptions.get (exception).getXMLName ();
                write (wsdl_file, "        <wsdl:fault name=\"" + xml_name + "\">\n" + "          <soap:fault name=\"" + xml_name + "\" use=\"literal\"/>\n" + "        </wsdl:fault>\n");
              }
            write (wsdl_file, "      </wsdl:operation>\n");
          }

        write (wsdl_file, "\n    </wsdl:binding>\n\n" + "  <wsdl:service name=\"" + service_name + "\">\n" + "     <wsdl:port name=\"" + service_name + ".Port\" binding=\"tns:" + service_name + ".Binding\">\n" + "       <soap:address location=\"" + default_url + "\"/>\n" + "     </wsdl:port>\n" + "  </wsdl:service>\n\n" + "</wsdl:definitions>\n");
        close (wsdl_file);
        javaTerminate (jserver_pck);
        javaTerminate (jclient_pck);
        if (jclient)
          {
            jclient_pck.openAddedClass (service_name);
            addImport ("javax.xml.ws.WebServiceClient");
            addImport ("javax.xml.ws.WebEndpoint");
            addImport ("javax.xml.ws.Service");
            addImport ("javax.xml.namespace.QName");
            jclient_pck.writeImports ();
            writeln (jclient_pck.jfile, "\n" +
                "@WebServiceClient(name=\"" + service_name + "\",\n" +
                "                  targetNamespace=\"" + tns + "\")\n" +
                "public class " + service_name + " extends Service\n" +
                "  {\n" +
                "    public " + service_name + " ()\n" +
                "      {\n" +
                "        super (" + service_name + ".class.getResource (\"/" + wsdl_location + "\"),\n" +
                "               new QName (\"" + tns + "\", \"" + service_name + "\"));\n" +
                "      }\n" +
                "\n" +
                "    @WebEndpoint(name=\"" + service_name + ".Port\")\n" +
                "    public " + jclient_pck.class_name + " get" + service_name + "Port ()\n" +
                "      {\n" +
                "        return super.getPort (new QName (\"" + tns + "\", \"" + service_name + ".Port\"),\n" +
                "                              " + jclient_pck.class_name + ".class);\n" +
                "      }\n" +
                "  }");
            close (jclient_pck);
            for (WSException wse : exceptions.values ())
              {
                jclient_pck.openAddedClass (wse.getBeanName ());
                addImport ("javax.xml.bind.annotation.XmlAccessType");
                addImport ("javax.xml.bind.annotation.XmlAccessorType");
                addImport ("javax.xml.bind.annotation.XmlElement");
                addImport ("javax.xml.bind.annotation.XmlType");
                for (Property prop : wse.properties)
                  {
                    if (prop.listtype)
                      {
                        addImport ("java.util.List");
                      }
                  }
                jclient_pck.writeImports ();
                write (jclient_pck.jfile, "\n" + "@XmlAccessorType(XmlAccessType.NONE)\n" + "@XmlType(propOrder={");
                boolean next = false;
                for (Property prop : wse.properties)
                  {
                    if (next)
                      {
                        write (jclient_pck.jfile, ",\n                    ");
                      }
                    else
                      {
                        next = true;
                      }
                    write (jclient_pck.jfile, "\"" + prop.name + "\"");
                  }
                writeln (jclient_pck.jfile, "})\npublic class " + wse.getBeanName () + "\n  {");
                next = false;
                for (Property prop : wse.properties)
                  {
                    if (next) write (jclient_pck.jfile, "\n");
                    next = true;
                    writeln (jclient_pck.jfile, "    @XmlElement(required=" + (!prop.nullable) + ", name=\"" + prop.getXMLName () + "\", namespace=\"\")\n    " + prop.jName (false) + " " + prop.name + ";");
                  }
                for (Property prop : wse.properties)
                  {
                    if (next) write (jclient_pck.jfile, "\n");
                    next = true;
                    String methn = prop.name;
                    writeln (jclient_pck.jfile, "    public " + prop.jName (false) + " get" + methn.substring (0, 1).toUpperCase () + methn.substring (1) + " ()\n      {\n        return " + prop.name + ";\n      }");
                  }
                writeln (jclient_pck.jfile, "  }");
                close (jclient_pck);
                jclient_pck.openAddedClass (wse.getName ());
                addImport ("javax.xml.ws.WebFault");
                jclient_pck.writeImports ();
                write (jclient_pck.jfile, "\n" + "@SuppressWarnings(\"serial\")\n" + "@WebFault(name=\"" + wse.getXMLName () + "\",\n" + "          targetNamespace=\"" + tns + "\")\n" + "public class " + wse.getName () + " extends Exception\n" + "  {\n" + "    /**\n" + "     * Java type that goes as soapenv:Fault detail element.\n" + "     */\n" + "    private " + wse.getBeanName () + " faultInfo;\n" + "\n" + "    /**\n" + "     * @param message\n" + "     * @param faultInfo\n" + "     */\n" + "    public " + wse.getName () + " (String message, " + wse.getBeanName () + " faultInfo)\n" + "      {\n" + "         super (message);\n" + "         this.faultInfo = faultInfo;\n" + "      }\n" + "\n" + "    /**\n" + "     * @param message\n" + "     * @param faultInfo\n" + "     * @param cause\n" + "     */\n" + "    public " + wse.getName () + " (String message, " + wse.getBeanName () + " faultInfo, Throwable cause)\n" + "      {\n" + "        super (message, cause);\n" + "        this.faultInfo = faultInfo;\n" + "      }\n" + "\n" + "    /**\n" + "     * @return fault bean\n" + "     */\n" + "    public " + wse.getBeanName () + " getFaultInfo ()\n" + "      {\n" + "        return faultInfo;\n" + "      }\n" + "  }\n");

                close (jclient_pck);
              }
          }
        if (dotnet_client_pck != null)
          {
            writeDotNet ();
          }
      }

    private void writeNetWrapper (boolean request, Method meth) throws IOException
      {
        Collection<Property> props = request ? meth.inputs : meth.outputs;
        FileOutputStream file = dotnet_client_pck.jfile;
        String class_name = meth.getNetWrapper (request);

        write (file, "\n" +
            "    [System.Diagnostics.DebuggerStepThroughAttribute()]\n" +
            "    [System.ServiceModel.MessageContractAttribute(WrapperName=\"" + (request ? meth.getXMLName () : meth.getXMLResponseName ()) + "\", WrapperNamespace=\"" + tns + "\", IsWrapped=true)]\n" +
            "    public class " + class_name + "\n" +
            "    {\n");
        int order = 0;
        for (Property prop : props)
          {
            write (file, "        [System.ServiceModel.MessageBodyMemberAttribute(Namespace=\"" + tns + "\", Order=" + (order++) + ")]\n" + "        [System.Xml.Serialization.XmlElementAttribute(ElementName=\"" + prop.getXMLName () + "\", Form=System.Xml.Schema.XmlSchemaForm." + (qualified_ns ? "Q" : "Unq") + "ualified)]\n" + "        public " + prop.nName () + " " + (prop.name.equals ("return") ? "@" : "") + prop.name + ";\n\n");
          }

        write (file, "        public " + class_name + "()\n" + 
                     "        {\n" + 
                     "        }\n");
        if (request && props.size () != 0)
          {
            write (file, "\n        public " + class_name + "(");
            meth.writeNetTypedInput (false);
            write (file, ")\n        {\n");
            for (Property prop : meth.inputs)
              {
                write (file, "            this." + prop.name + " = " + prop.name + ";\n");
              }
            write (file, "        }\n");
          }
        write (file, "    }\n");
      }

    private void writeDotNet () throws IOException
      {
        FileOutputStream file = dotnet_client_pck.jfile;
        writeln (file, license_header + "namespace " + dotnet_client_pck.package_name + "\n{\n");
        writeGenerate (file);
        dotnet_client_pck.writeImports ();
        write (file, "\n" + dotnet_client_pck.class_header +
            "    [System.ServiceModel.ServiceContractAttribute(Namespace=\"" + tns + "\")]\n" +
            "    public interface " + dotnet_client_pck.class_name + "Interface\n" +
            "    {\n");
        boolean next = false;
        for (Method meth : methods)
          {
            if (next)
              {
                write (file, "\n");
              }
            else
              {
                next = true;
              }
            write (file, "        [System.ServiceModel.OperationContractAttribute(Action=\"\", ReplyAction=\"*\")]\n");
            for (String ex : meth.execptions)
              {
                writeln (file, "        [System.ServiceModel.FaultContractAttribute(typeof(" + exceptions.get (ex).getName () + "Attributes), Action=\"\", Name=\"" + exceptions.get (ex).getName () + "\")]");
              }
            write (file, "        [System.ServiceModel.XmlSerializerFormatAttribute()]\n" + "        " + meth.getNetWrapper (false) + " " + meth.name + "(" + meth.getNetWrapper (true) + " request);\n");
          }
        write (file, "    }\n");
        for (String ex : exceptions.keySet ())
          {
            WSException wse = exceptions.get (ex);
            write (file, "\n" +
                "    [System.Diagnostics.DebuggerStepThroughAttribute()]\n" + 
                "    public class " + wse.getName () + "Attributes : System.Xml.Serialization.IXmlSerializable\n" +
                "    {\n" + 
                "        private System.Xml.XmlNode[] nodes;\n\n" +
                "        public System.Xml.Schema.XmlSchema GetSchema()\n" +
                "        {\n" +
                "            return null;\n" +
                "        }\n\n" +
                "        public void ReadXml(System.Xml.XmlReader reader)\n" +
                "        {\n" +
                "            nodes = System.Runtime.Serialization.XmlSerializableServices.ReadNodes(reader);\n" +
                "        }\n\n" +
                "        public void WriteXml(System.Xml.XmlWriter writer)\n" +
                "        {\n" +
                "            System.Runtime.Serialization.XmlSerializableServices.WriteNodes(writer, nodes);\n" +
                "        }\n");
            int index = 0;
            for (Property prop : wse.properties)
              {
                String methn = prop.name;
                String value = "nodes[" + (index++) + "].InnerXml";
                if (!prop.nName ().equals ("string"))
                  {
                    value = "System.Int32.Parse(" + value + ")";
                  }
                writeln (file, "\n" +
                               "        public " + prop.nName () + " get" + methn.substring (0, 1).toUpperCase () + methn.substring (1) + "()\n" + 
                               "        {\n" +
                               "            return " + value + ";\n" +
                               "        }");
              }
            write (file, "    }\n");
          }

        for (Method meth : methods)
          {
            writeNetWrapper (true, meth);
            writeNetWrapper (false, meth);
          }
        write (file, "\n" +
                     "    public class " + dotnet_client_pck.class_name + " : System.ServiceModel.ClientBase<" + dotnet_client_pck.class_name + "Interface>\n" +
                     "    {" + dotnet_client_pck.dot_net_support_code + "\n" +
                     "        public static " + dotnet_client_pck.class_name + " getDefault" + dotnet_client_pck.class_name + "()\n" +
                     "        {\n" +
                     "            ");
        if (dot_net_registry_url == null && dot_net_default_url == null)
          {
            write (file, "throw new System.ArgumentException(\"Default proxy not configured in WS definition input file!\");\n");
          }
        else
          {
            if (dot_net_registry_url != null)
              {
                int i = dot_net_registry_url.lastIndexOf ('\\');
                if (i <= 0) bad ("Bad RegistryURL definition");
                write (file, "string ws_url = (string) Microsoft.Win32.Registry.GetValue(\"" + dot_net_registry_url.substring (0, i - 1) +"\", \"" + dot_net_registry_url.substring (i + 1) + "\", null);\n" +
                       "            if (ws_url == null)\n" +
                       "            {\n" +
                       "                 ");
                if (dot_net_default_url == null)
                  {
                    write (file, "throw new System.ArgumentException(\"No such registry entry: " + dot_net_registry_url + "\")");
                  }
                else
                  {
                    write (file, "ws_url = \"" + dot_net_default_url + "\"");
                  }
                write (file, ";\n" +
                    "            }\n" +
                    "            ");
              }                
            write (file,
                "System.ServiceModel.BasicHttpBinding ws_bind = new System.ServiceModel.BasicHttpBinding();\n" +
                "            ws_bind.SendTimeout = System.TimeSpan.FromMinutes(5);\n" +
                "            return new " + dotnet_client_pck.class_name +
                  "(ws_bind, new System.ServiceModel.EndpointAddress(" +
                  (dot_net_registry_url == null ? "\"" +  dot_net_default_url + "\"" : "ws_url") +
                  "));\n");
          }
        write (file,
                     "        }\n\n" +
                     "        public " + dotnet_client_pck.class_name + 
                                         "(string endpointConfigurationName) " +
                                         ": base(endpointConfigurationName)\n" +
                     "        {\n" +
                     "        }\n\n" +
                     "        public " + dotnet_client_pck.class_name + 
                                         "(System.ServiceModel.Channels.Binding binding, System.ServiceModel.EndpointAddress remoteAddress) " + 
                                         ": base(binding, remoteAddress)\n" +
                     "        {\n" +
                     "        }\n");
        for (Method meth : methods)
          {
            write (file, "\n" + "        public ");

            if (meth.outputs.isEmpty () || meth.outputs.size () > 1)
              {
                write (file, "void");
              }
            if (meth.outputs.size () == 1)
              {
                Property prop = meth.outputs.iterator ().next ();
                write (file, prop.nName ());
              }
            write (file, " " + meth.name + "(");
            meth.writeNetTypedInput (true);
            if (meth.outputs.size () > 1)
              {
                meth.writeNetTypedOutput ();
              }
            write (file, ")\n" +
                "        {\n" + 
                "            ");
            if (meth.outputs.size () == 1)
              {
                write (file, "return ");
              }
            else if (meth.outputs.size () > 1)
              {
                write (file, meth.getNetWrapper (false) + " _res = ");
              }
            write (file, "base.Channel." + meth.name + "(new " + meth.getNetWrapper (true) + "(");
            next = false;
            for (Property prop : meth.inputs)
              {
                if (next)
                  {
                    write (file, ", ");
                  }
                else
                  {
                    next = true;
                  }
                write (file, prop.nArgument (""));
              }
            write (file, "))");
            if (meth.outputs.size () == 1)
              {
                write (file, ".@return");
              }
            writeln (file, ";");
            if (meth.outputs.size () > 1) for (Property prop : meth.outputs)
              {
                write (file, "            " + prop.name + " = " + prop.nArgument ("_res.") + ";\n");
              }
            write (file, "        }\n");
          }
        writeln (file, "    }\n}");
        close (dotnet_client_pck);
      }

    private void close (Package pck) throws IOException
      {
        close (pck.jfile);
      }

    private void addImport (String string)
      {
        jimports.add (string);
      }

    private void javaHeader (Package pck) throws IOException
      {
        if (pck == null) return;
        FileOutputStream jfile = pck.jfile;
        pck.writePackage ();
        pck.writeImports ();
        write (jfile, "\n" + pck.class_header);
        if (pck.schema_validation)
          {
            write (jfile, "@com.sun.xml.ws.developer.SchemaValidation\n");
          }
        if (pck.jserver_support_code.length () > 0)
          {
            pck.next = true;
          }
        write (jfile, "@WebService(serviceName=\"" + service_name + "\",\n" + "            targetNamespace=\"" + tns + "\"" + pck.decoration () + ")\npublic " + pck.class_interface () + " " + pck.class_name + "\n  {\n" + pck.jserver_support_code);
      }

    private void javaTerminate (Package pck) throws IOException
      {
        if (pck != null)
          {
            if (add_main)
              {
                writeln (pck.jfile, "\n" + 
                                    "    public static void main (String[] args)\n" +
                                    "      {\n" +
                                    "        if (args.length != 1)\n" + 
                                    "          {\n" +
                                    "            System.out.println (\"Missing URL\");\n" +
                                    "          }\n" +
                                    "        Endpoint endpoint = Endpoint.create (new " + pck.class_name + " ());\n" +
                                    "        endpoint.publish (args[0]);\n" +
                                    "      }");
              }
            write (pck.jfile, "  }\n");
            close (pck);
          }

      }

    void javaMethod (Package pck, Method meth) throws IOException
      {
        if (pck == null) return;
        FileOutputStream jfile = pck.jfile;
        if (pck.next)
          {
            write (jfile, "\n");
          }
        pck.next = true;
        writeln (jfile, "    @WebMethod(operationName=\"" + meth.getXMLName () + "\")\n" + "    @RequestWrapper(localName=\"" + meth.getXMLName () + "\", targetNamespace=\"" + tns + "\")\n" + "    @ResponseWrapper(localName=\"" + meth.getXMLResponseName () + "\", targetNamespace=\"" + tns + "\")");
        int indent = 4;
        if (meth.outputs.isEmpty () || meth.outputs.size () > 1)
          {
            write (jfile, "    public void");
          }
        if (meth.outputs.size () == 1)
          {
            Property prop = meth.outputs.iterator ().next ();
            write (jfile, "    @WebResult(name=\"" + prop.getXMLName () + sub_target_ns + ")\n    public ");
            write (jfile, prop.jName (false));
            indent = prop.jName (false).length ();
          }
        write (jfile, " " + meth.name + " (");
        indent += meth.name.length ();
        boolean next = false;
        for (Property prop : meth.inputs)
          {
            if (next)
              {
                writeln (jfile, ",");
                for (int i = -14; i < indent; i++)
                  {
                    write (jfile, " ");
                  }
              }
            writeln (jfile, "@WebParam(name=\"" + prop.getXMLName () + sub_target_ns + ")");
            for (int i = -14; i < indent; i++)
              {
                write (jfile, " ");
              }
            write (jfile, prop.jName (false) + " " + prop.name);
            next = true;
          }
        if (meth.outputs.size () > 1) for (Property prop : meth.outputs)
          {
            if (next)
              {
                writeln (jfile, ",");
                for (int i = -14; i < indent; i++)
                  {
                    write (jfile, " ");
                  }
              }
            writeln (jfile, "@WebParam(name=\"" + prop.getXMLName () + sub_target_ns + ", mode=WebParam.Mode.OUT)");
            for (int i = -14; i < indent; i++)
              {
                write (jfile, " ");
              }
            write (jfile, "Holder<" + prop.jName (true) + "> " + prop.name);
            next = true;
          }
        write (jfile, ")");
        next = false;
        for (String ex : meth.execptions)
          {
            if (next)
              {
                write (jfile, ", ");
              }
            else
              {
                next = true;
                write (jfile, "\n    throws ");
              }
            write (jfile, exceptions.get (ex).getName ());
          }
        write (jfile, meth.code + "\n");
      }

    private void open (Package pck, boolean java) throws IOException
      {
        if (pck != null)
          {
            new File (pck.path).mkdirs ();
            pck.jfile = new FileOutputStream (pck.path + File.separatorChar + pck.class_name + (java ? ".java" : ".cs"));
          }
      }

    private void writeWSDLProperties (String element_name, Collection<Property> properties, boolean unqualified) throws IOException
      {
        write (wsdl_file, "\n" + 
                          "      <xs:element name=\"" + element_name + "\"");
        if (properties.size () == 0)
          {
            write (wsdl_file, "/");
          }
        else
          {
            write (wsdl_file, ">\n" +
                              "        <xs:complexType>\n" +
                              "          <xs:sequence>\n");
            for (Property property : properties)
              {
                write (wsdl_file, "            <xs:element name=\"" + property.getXMLName () + "\" type=\"" + property.data_type.xsd_name + "\"" + (unqualified ? " form=\"unqualified\"" : "") + (property.nullable ? " minOccurs=\"0\"" : "") + (property.listtype ? " maxOccurs=\"unbounded\"" : "") + "/>\n");
              }
            write (wsdl_file, "          </xs:sequence>\n" +
                              "        </xs:complexType>\n" +
                              "      </xs:element");
          }
        writeln (wsdl_file, ">");
      }

    private Collection<Property> getProperties (DOMReaderHelper rd, String property) throws IOException
      {
        LinkedHashMap<String, Property> props = new LinkedHashMap<String, Property> ();
        HashSet<String> xsd_names = new HashSet<String> ();
        while (rd.hasNext (property))
          {
            rd.getNext ();
            Property prop = new Property ();
            prop.name = attr.getString ("Name");
            prop.xml_name = attr.getStringConditional ("XMLName");
            if (!xsd_names.add (prop.getXMLName ()))
              {
                bad ("Duplicate XML name: " + prop.getXMLName ());
              }
            String type = attr.getString ("Type");
            prop.nullable = attr.getBoolean ("Null");
            if (prop.listtype = attr.getBoolean ("List"))
              {
                addImport ("java.util.List");
              }
            String dotnet_rule = attr.getStringConditional ("DotNetRule");
            if (dotnet_rule != null)
              {
                DotNetRule dnr = dot_net_rules.get (dotnet_rule);
                if (dnr == null)
                  {
                    bad ("Unknown .NET rule: " + dotnet_rule);
                  }
                prop.dot_net_rule = dnr;
              }
            for (DataType dtype : types)
              {
                if (dtype.enum_name.equals (type))
                  {
                    prop.data_type = dtype;
                    break;
                  }
              }
            if (prop.data_type == null)
              {
                bad ("Type '" + type + "' not found");
              }
            if (props.put (prop.name, prop) != null)
              {
                bad ("Duplicate property: " + prop.name);
              }
          }
        return props.values ();
      }

    private void bad (String string) throws IOException
      {
        throw new IOException (string);
      }

    private void close (FileOutputStream file) throws IOException
      {
        if (file != null) file.close ();
      }

    private void write (FileOutputStream file, String data) throws IOException
      {
        if (file != null)
          {
            file.write (data.getBytes ("UTF-8"));
          }
      }

    private void writeln (FileOutputStream file, String data) throws IOException
      {
        write (file, data + "\n");
      }

    @Override
    protected void toXML (DOMWriterHelper ws) throws IOException
      {
        // TODO Auto-generated method stub
      }

    @Override
    public String namespace ()
      {
        return "http://xmlns.webpki.org/wscreator.1.00";
      }

    @Override
    public String element ()
      {
        return "WebService";
      }

    private static void show ()
      {
        System.out.println (WSCreator.class.getName () + " '" + JCLIENT + "'|'" + JSERVER + "'|'" + WSDL + "'|'" + DOTNETCLIENT + "' input-file output-directory\n" + "Note: output-directory is actually file-name for the '" + WSDL + "' option");
        System.exit (3);
      }

    public static void main (String args[])
      {
        if (args.length != 3) show ();
        if (args[0].equals (JCLIENT)) jclient = true;
        else if (args[0].equals (JSERVER)) jserver = true;
        else if (args[0].equals (WSDL)) wsdl_gen = true;
        else if (args[0].equals (DOTNETCLIENT)) dotnet_gen = true;
        else
          show ();
        output_directory = args[2];
        try
          {
            XMLSchemaCache xsc = new XMLSchemaCache ();
            xsc.addWrapper (WSCreator.class);
            xsc.parse (ArrayUtil.readFile (args[1]));
          }
        catch (IOException iox)
          {
            iox.printStackTrace ();
            System.exit (3);
          }
      }

  }
