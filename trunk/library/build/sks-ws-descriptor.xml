<?xml version="1.0" encoding="UTF-8"?>
<!-- SKS WS Descriptor File to be used with "WSCreator" -->
<WebService NameSpace="http://xmlns.webpki.org/sks/v1.00"
            Service="SKSWS"
            DefaultURL="http://localhost:8080/securekeystore"
            WSDLLocation="META-INF/SKSWS.wsdl"
            Qualified="true"
            xmlns="http://xmlns.webpki.org/wscreator.1.00">

   <LicenseHeader><![CDATA[
  Copyright 2006-2011 WebPKI.org (http://webpki.org).

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.

]]></LicenseHeader>

   <JavaServer ClassName="org.webpki.sks.ws.server.SKSWSImplementation"
               Imports="java.util.ArrayList
                        java.security.GeneralSecurityException
                        java.security.Security
                        java.security.spec.X509EncodedKeySpec
                        java.security.KeyFactory
                        java.security.PublicKey
                        java.security.cert.X509Certificate
                        java.security.interfaces.ECPublicKey
                        java.security.interfaces.RSAPublicKey
                        java.io.IOException
                        org.bouncycastle.jce.provider.BouncyCastleProvider
                        org.webpki.crypto.test.DemoKeyStore
                        org.webpki.sks.EnumeratedKey
                        org.webpki.sks.ProvisioningSession
                        org.webpki.sks.DeviceInfo
                        org.webpki.sks.SecureKeyStore">
     <ClassHeader><![CDATA[/**
 * SKS Web Service Implementation.
 *
 * The purpose of the Web Service is creating a "singleton"
 * service that can concurrently be called by arbitrary
 * SKS-using applications.  The Web Service can be connected
 * to any conformant SKS implementation.
 */ 
]]></ClassHeader>
     <SupportCode><![CDATA[
    static SecureKeyStore sks;
    
    static DeviceInfo device_info;
    
    static
      {
        try
          {
            Security.insertProviderAt (new BouncyCastleProvider(), 1);
            sks = (SecureKeyStore) Class.forName (System.getProperty ("sks.implementation")).newInstance ();
            device_info = sks.getDeviceInfo ();
            System.out.println ("Device: " + device_info.getVendorDescription ());
            System.out.println ("Vendor: " + device_info.getVendorName ());
            System.out.println ("API Version: " + device_info.getAPILevel () + "\n");
          }
        catch (ClassNotFoundException e)
          {
            throw new RuntimeException (e);
          }
        catch (InstantiationException e)
          {
            throw new RuntimeException (e);
          }
        catch (IllegalAccessException e)
          {
            throw new RuntimeException (e);
          }
        catch (SKSException e)
          {
            throw new RuntimeException (e);
          }
      }
    
    PublicKey createPublicKeyFromBlob (byte[] blob) throws SKSException
      {
        X509EncodedKeySpec ks = new X509EncodedKeySpec (blob);
        KeyFactory kf = null;
        try
          {
            kf = KeyFactory.getInstance ("RSA");
            return kf.generatePublic(ks);
          }
        catch (GeneralSecurityException e1)
          {
            try
              {
                kf = KeyFactory.getInstance ("EC");
                return kf.generatePublic(ks);
              }
            catch (GeneralSecurityException e2)
              {
                throw new SKSException (e2);
              }
          }
      }
      
    ECPublicKey getECPublicKey (byte[] blob) throws SKSException
      {
        PublicKey public_key = createPublicKeyFromBlob (blob);
        if (public_key instanceof ECPublicKey)
          {
            return (ECPublicKey) public_key;
          }
        throw new SKSException ("Expected EC key");
      }
]]></SupportCode>
   </JavaServer>

   <JavaClient ClassName="org.webpki.sks.ws.client.SKSWSProxy">
     <ClassHeader><![CDATA[/**
 * This is the client :-)
 */
]]></ClassHeader>
   </JavaClient>
   <DotNetClient ClassName="org.webpki.sks.ws.client.SKSWSProxy"
                 RegistryURL="SOFTWARE\WebPKI.org\SKSWSURL"
                 PathAsDirectory="false">
     <ClassHeader><![CDATA[    /*
     *  This is the .NET SKS client.
     */
]]></ClassHeader>
     <SupportCode><![CDATA[
        public static string ALGORITHM_SESSION_KEY_ATTEST_1 = "http://xmlns.webpki.org/keygen2/1.0#algorithm.sks.s1";

        public static string ALGORITHM_KEY_ATTEST_1         = "http://xmlns.webpki.org/keygen2/1.0#algorithm.sks.k1";

        X509Certificate2[] blist2certs (List<byte[]> blist)
        {
            X509Certificate2[] certs = new X509Certificate2[blist.Count];
            int i = 0;
            foreach (byte[] b_arr in blist)
            {
                certs[i++] = new X509Certificate2(b_arr);
            }
            return i == 0 ? null : certs;
        }

        List<byte[]> certs2blist (X509Certificate2[] certs)
        {
            List<byte[]> blist = new List<byte[]>();
            if (certs != null) foreach (X509Certificate2 cert in certs)
            {
                blist.Add (cert.RawData);
            }
            return blist;
        }
]]></SupportCode>
     <RewriteRule DotNetRule="Out.X509"
                  ActualType="System.Security.Cryptography.X509Certificates.X509Certificate2"
                  Conversion="blist2certs($)"/>
     <RewriteRule DotNetRule="In.X509"
                  ActualType="System.Security.Cryptography.X509Certificates.X509Certificate2"
                  Conversion="certs2blist($)"/>
     </DotNetClient>

   <Exception ClassName="org.webpki.sks.SKSException">
     <Property Name="error" Type="int"/>
     <Property Name="message" Type="string"/>
   </Exception>

   <Method Name="createProvisioningSession" Throws="SKSException">
     <Parameter Name="algorithm"            Type="string" XMLName="Algorithm"       />
     <Parameter Name="server_session_id"    Type="string" XMLName="ServerSessionID"/>
     <Parameter Name="server_ephemeral_key" Type="binary" XMLName="ServerEphemeralKey"/>
     <Parameter Name="issuer_uri"           Type="string" XMLName="IssuerURI"/>
     <Parameter Name="key_management_key"   Type="binary" XMLName="KeyManagementKey" Null="true"/>
     <Parameter Name="client_time"          Type="int"    XMLName="ClientTime"/>
     <Parameter Name="session_life_time"    Type="int"    XMLName="SessionLifeTime"/>
     <Parameter Name="session_key_limit"    Type="short"  XMLName="SessionKeyLimit"/>
     <Parameter Name="client_session_id"    Type="string" XMLName="ClientSessionID"    Mode="out"/>
     <Parameter Name="client_ephemeral_key" Type="binary" XMLName="ClientEphemeralKey" Mode="out"/>
     <Parameter Name="attestation"          Type="binary" XMLName="Attestation"        Mode="out"/>
     <Parameter Name="provisioning_handle"  Type="int"    XMLName="ProvisioningHandle" Mode="out"/>
     <Code><![CDATA[
        System.out.println ("SERV=" + (server_ephemeral_key == null ? "NULL" : server_ephemeral_key.length) + " KMK=" + (key_management_key == null ? "NULL" : key_management_key.length));
        try
          {
        org.webpki.asn1.BaseASN1Object o = org.webpki.asn1.DerDecoder.decode(server_ephemeral_key, 0);
        System.out.println(o.toString (true, true));
          }
        catch (IOException e)
          {
            System.out.println ("ASN1" + e.getMessage ());
          }
        ProvisioningSession sess = sks.createProvisioningSession (algorithm,
                                                                  server_session_id,
                                                                  getECPublicKey (server_ephemeral_key),
                                                                  issuer_uri,
                                                                  key_management_key == null ? null : createPublicKeyFromBlob (key_management_key),
                                                                  client_time,
                                                                  session_life_time,
                                                                  session_key_limit);
        client_session_id.value = sess.getClientSessionID ();
        client_ephemeral_key.value = sess.getClientEphemeralKey ().getEncoded ();
        attestation.value = sess.getAttestation ();
        provisioning_handle.value = sess.getProvisioningHandle ();
]]></Code></Method>

   <Method Name="abortProvisioningSession" Throws="SKSException">
     <Parameter Name="provisioning_handle" XMLName="ProvisioningHandle" Type="int"/>
     <Code><![CDATA[
        if (provisioning_handle == 5)
          {
            throw new SKSException ("bad",4);
          }
        sks.abortProvisioningSession (provisioning_handle);
]]></Code></Method>

   <Method Name="enumerateKeys" Throws="SKSException">
     <Parameter Name="key_handle" XMLName="KeyHandle" Type="int" Mode="inout"/>
     <Parameter Name="provisioning_handle" XMLName="ProvisioningHandle" Type="int" Mode="out"/>
     <Code><![CDATA[
        EnumeratedKey ek = sks.enumerateKeys (new EnumeratedKey (key_handle.value, 0));
        key_handle.value = ek.getKeyHandle ();
        provisioning_handle.value = ek.getProvisioningHandle ();
]]></Code></Method>

   <Method Name="getKeyProtectionInfo" Throws="SKSException">
     <Returns Type="int"/>
     <Parameter Name="key_handle" Type="int" XMLName="keyHandle"/>
     <Parameter Name="protection_status" Mode="inout" Type="string" XMLName="ProtectionStatus"/>
     <Parameter Name="blah" Mode="out" Type="byte"/>
     <Parameter Name="certificate_path" Mode="out" Type="binary" XMLName="X509Certificate" DotNetRule="Out.X509" List="true"/>
     <Code><![CDATA[
        protection_status.value = protection_status.value + "@";
        blah.value = (byte)(key_handle + 2);
        List<byte[]> certs = new ArrayList<byte[]> ();
        try
          {
            certs.add (DemoKeyStore.getCAKeyStore ().getCertificate ("mykey").getEncoded ());
            certs.add (DemoKeyStore.getSubCAKeyStore ().getCertificate ("mykey").getEncoded ());
          }
        catch (GeneralSecurityException gse)
          {
            throw new SKSException (gse);
          }
        catch (IOException iox)
          {
            throw new SKSException (iox);
          }
        certificate_path.value = certs;
        return 800;
]]></Code></Method>

   <Method Name="setCertificatePath" Throws="SKSException">
     <Parameter Name="key_handle" Type="int" XMLName="KeyHandle"/>
     <Parameter Name="certificate_path" Type="binary" XMLName="X509Certificate" DotNetRule="In.X509" List="true" Null="true"/>
     <Parameter Name="mac" Type="binary" XMLName="MAC"/>
     <Code><![CDATA[
        StringBuffer res = new StringBuffer ();
        if (certificate_path.size() == 0)
          {
            res.append ("'null'");
          }
        else
          {
            int i = 0;
            for (byte[] b_arr : certificate_path)
              {
                if (i != 0)
                  {
                     res.append ("\n      ");
                  }
                try
                  {
                    res.append ("C[" + (i++) + "]=" + new org.webpki.crypto.CertificateInfo(org.webpki.crypto.CertificateUtil.getCertificateFromBlob (b_arr)).getSubject ());
                  }
                catch (IOException iox)
                  {
                    throw new SKSException (iox);
                  }
              }
          }
        System.out.println ("Certs=" + res.toString () + " mac=" + mac.length);
]]></Code></Method>

   <Method Name="getVersion">
     <Returns Type="string"/>
     <Code><![CDATA[
        return "0.00001";
]]></Code></Method>

   <Method Name="getCertPath" Throws="SKSException">
     <Returns Type="binary" XMLName="X509Certificate" DotNetRule="Out.X509" List="true" Null="true"/>
     <Parameter Type="boolean" Name="want"/>
     <Code><![CDATA[
        List<byte[]> certs = new ArrayList<byte[]> ();
        try
          {
            certs.add (DemoKeyStore.getCAKeyStore ().getCertificate ("mykey").getEncoded ());
            certs.add (DemoKeyStore.getSubCAKeyStore ().getCertificate ("mykey").getEncoded ());
          }
        catch (GeneralSecurityException gse)
          {
            throw new SKSException (gse);
          }
        catch (IOException iox)
          {
            throw new SKSException (iox);
          }
        return want ? certs : null;
]]></Code></Method>

</WebService>
